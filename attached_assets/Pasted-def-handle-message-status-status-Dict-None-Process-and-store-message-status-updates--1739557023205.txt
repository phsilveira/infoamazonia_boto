def handle_message_status(status: Dict) -> None:
    """Process and store message status updates"""
    try:
        whatsapp_message_id = status['id']
        message = Message.query.filter_by(whatsapp_message_id=whatsapp_message_id).first()

        if not message:
            message = Message(
                whatsapp_message_id=whatsapp_message_id,
                phone_number=status['recipient_id'],
                message_type='outgoing',
                status=status['status'],
                status_timestamp=datetime.fromtimestamp(int(status['timestamp']))
            )
        else:
            message.status = status['status']
            message.status_timestamp = datetime.fromtimestamp(int(status['timestamp']))

        # Handle failed messages
        if status['status'] == 'failed' and 'errors' in status:
            error = status['errors'][0]
            message.error_code = error.get('code')
            message.error_title = error.get('title')
            message.error_message = error.get('message')

        db.session.add(message)
        db.session.commit()
        logger.info(f"Updated message status: {status['status']} for {whatsapp_message_id}")
    except Exception as e:
        logger.error(f"Error processing message status: {str(e)}")
        db.session.rollback()

def process_incoming_message(message_data: Dict, phone_number: str) -> None:
    """Process incoming messages and queue them for handling"""
    try:
        # Log incoming message
        message = Message(
            whatsapp_message_id=message_data['id'],
            phone_number=phone_number,
            message_type='incoming',
            message_content=message_data['text']['body'],
            status='received',
            status_timestamp=datetime.fromtimestamp(int(message_data['timestamp']))
        )
        db.session.add(message)
        db.session.commit()

        data_to_process = {
            "phone_number": phone_number,
            "message": message_data['text']['body']
        }

        # Get current state from Redis if available
        if current_app.redis:
            try:
                current_state = current_app.redis.get(f"state:{phone_number}")
                if current_state:
                    data_to_process['current_state'] = current_state
            except Exception as e:
                logger.error(f"Redis error while getting state: {e}")

        # Process webhook message asynchronously
        process_webhook_message.delay(data_to_process)
        logger.info(f"Successfully queued message from {phone_number} for processing")
    except Exception as e:
        logger.error(f"Error processing incoming message: {str(e)}")
        db.session.rollback()

def handle_unofficial_api_message(data: Dict) -> None:
    """Process messages from unofficial API format"""
    try:
        phone_number = data.get('phone') or data.get('phone_number')
        message_text = data.get('text') or data.get('message')

        # Avoid loop messages if phone is from the agent
        if data.get('fromApi'):
            return

        if not phone_number or not message_text:
            raise ValueError("Missing required fields")

        # Preprocess the payload
        if isinstance(message_text, dict):
            message_text = message_text.get('message')

        # Log incoming message
        message = Message(
            whatsapp_message_id=f"unofficial-{datetime.now().timestamp()}",
            phone_number=phone_number,
            message_type='incoming',
            message_content=message_text,
            status='received',
            status_timestamp=datetime.now()
        )
        db.session.add(message)
        db.session.commit()

        data_to_process = {
            "phone_number": phone_number,
            "message": message_text,
        }

        # Get current state from Redis if available
        if current_app.redis:
            try:
                current_state = current_app.redis.get(f"state:{phone_number}")
                if current_state:
                    data_to_process['current_state'] = current_state
            except Exception as e:
                logger.error(f"Redis error while getting state: {e}")

        # Process webhook message asynchronously
        process_webhook_message.delay(data_to_process)
        logger.info(f"Successfully queued unofficial message from {phone_number} for processing")
    except Exception as e:
        logger.error(f"Error processing unofficial message: {str(e)}")
        db.session.rollback()

def verify_webhook(mode: str, token: str, challenge: str) -> Tuple[Any, int]:
    """Handle WhatsApp Cloud API webhook verification"""
    if mode == 'subscribe' and token == current_app.config['WEBHOOK_VERIFY_TOKEN']:
        logger.info("Webhook verified successfully!")
        return challenge, 200
    else:
        logger.warning("Webhook verification failed.")
        return 'Forbidden', 403

@main_bp.route('/webhook', methods=['GET', 'POST'])
def webhook():
    """Handle incoming webhook requests for both official and unofficial API formats"""
    if request.method == 'GET':
        mode = request.args.get('hub.mode')
        token = request.args.get('hub.verify_token')
        challenge = request.args.get('hub.challenge')
        return verify_webhook(mode, token, challenge)

    # Handle POST requests
    try:
        data = request.get_json()
        logger.debug(f"Received webhook data: {data}")
        if not data:
            return jsonify({"error": "No data provided"}), 400

        # Handle WhatsApp Cloud API format
        if data.get('object') == 'whatsapp_business_account':
            for entry in data['entry']:
                for change in entry.get('changes', []):
                    if change.get('field') == 'messages':
                        value = change['value']

                        # Handle message status updates
                        if 'statuses' in value:
                            for status in value['statuses']:
                                handle_message_status(status)

                        # Handle incoming messages
                        if 'messages' in value:
                            for message_data in value['messages']:
                                if message_data['type'] == 'text':
                                    process_incoming_message(message_data, message_data['from'])
        else:
            # Handle unofficial API format
            handle_unofficial_api_message(data)

        return jsonify({
            "status": "success",
            "message": "Webhook received and being processed"
        })

    except Exception as e:
        logger.error(f"Error in webhook endpoint: {str(e)}")
        return jsonify({"error": "Internal server error"}), 500