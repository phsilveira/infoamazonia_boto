# services/chatgpt.py
import requests
import logging
from flask import current_app
from typing import Optional, Dict

logger = logging.getLogger(__name__)

class ChatGPTService:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.api_url = "https://api.openai.com/v1/chat/completions"
        self.headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

    def _make_request(self, messages: list) -> Optional[Dict]:
        try:
            response = requests.post(
                self.api_url,
                headers=self.headers,
                json={
                    "model": "gpt-4o",
                    "messages": messages,
                    "temperature": 0.1,
                    "max_tokens": 150
                }
            )
            response.raise_for_status()
            return response.json()
        except Exception as e:
            logger.error(f"Error calling ChatGPT API: {str(e)}")
            return None

    def validate_location(self, location: str) -> tuple[bool, str]:
        """Validate and correct a location name"""
        messages = [
            {"role": "system", "content": "You are a helpful assistant that validates Brazilian Amazon locations."},
            {"role": "user", "content": f"Is '{location}' a valid location (city, region, state, popular expression) in the Brazil? If it's valid but has typos, correct the location_name. If it's not valid, explain why. Also the user can insert multiple locations in a same message, if any of the locations is invalid then answer with the location invalid only Response format: 'VALID|INVALID|location_names|explanation'"}
        ]

        response = self._make_request(messages)
        if not response or not response.get('choices'):
            return False, "Could not validate location"

        result = response['choices'][0]['message']['content'].split('|')
        is_valid = result[0] == 'VALID'
        corrected_location = result[1] if len(result) > 2 else location

        return is_valid, corrected_location

    def validate_subject(self, subject: str) -> tuple[bool, str]:
        """Validate and categorize a subject related to Amazon"""
        messages = [
            {"role": "system", "content": "You are a helpful assistant that validates and categorizes subjects related to the Amazon rainforest."},
            {"role": "user", "content": f"""Is ‘{subject}’ a valid subject related to the Amazon rainforest?
    •	Examples of valid subjects:
    1.	Conservação e clima
    2.	Povos originários e territórios
    3.	Política e economia amazônica
    4.	Biodiversidade e saúde ambiental
    5.	Saúde e educação na Amazônia
    6.	Mineração em terras indígenas
etc.
    •	Instructions for validation:
    •	If the input is a number (1-6), map it to the corresponding example subject above.
    •	If the input is a subject text, check its relevance to the examples provided.
    •	If valid but needs correction, provide the corrected version of the subject.
    •	If invalid, explain why it does not match any valid subject.

Response format:
VALID|INVALID|subject_name|explanation"""}
        ]

        response = self._make_request(messages)
        if not response or not response.get('choices'):
            return False, "Could not validate subject"

        result = response['choices'][0]['message']['content'].split('|')
        is_valid = result[0] == 'VALID'
        corrected_subject = result[1] if len(result) > 2 else subject

        return is_valid, corrected_subject

    def parse_confirmation(self, message: str) -> Optional[bool]:
        """Parse exact yes/no responses in English and Portuguese"""
        message = message.lower().strip()

        # Simple yes/no matching
        if message in ['yes', 'sim', 's']:
            return True
        elif message in ['no', 'não', 'nao', 'n']:
            return False

        return None